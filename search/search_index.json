{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PSR-2 Code Generator psr2-code-generator is a library to generate PHP code programmatically, via a nice fluent api. It's a light version of the awesome php-code-generator refactored to generate PSR-1 and PSR-2 code. Here are the main differences from the original library: PHP 7.2+ full strict type no reverse engeneering (model generation from an existent file) no reflection (model generation from an instance of a class) PHP 7.4 typed properties (optional) The generated code adheres to the following rules: PSR-1 and PSR-2 always strict type return types parameters types always PhpDoc comments Installation The library uses Composer as dependency manager. To install it run the following: composer require susina/psr2-code-generator Next Step Start reading the User Guide Issues If you find an issue or need some help, please open a ticket on Github repository . License psr2-code-generator is released under the Apache2 license. A full copy of the license is shipped with the code into the file LICENSE .","title":"Home"},{"location":"#welcome-to-psr-2-code-generator","text":"psr2-code-generator is a library to generate PHP code programmatically, via a nice fluent api. It's a light version of the awesome php-code-generator refactored to generate PSR-1 and PSR-2 code. Here are the main differences from the original library: PHP 7.2+ full strict type no reverse engeneering (model generation from an existent file) no reflection (model generation from an instance of a class) PHP 7.4 typed properties (optional) The generated code adheres to the following rules: PSR-1 and PSR-2 always strict type return types parameters types always PhpDoc comments","title":"Welcome to PSR-2 Code Generator"},{"location":"#installation","text":"The library uses Composer as dependency manager. To install it run the following: composer require susina/psr2-code-generator","title":"Installation"},{"location":"#next-step","text":"Start reading the User Guide","title":"Next Step"},{"location":"#issues","text":"If you find an issue or need some help, please open a ticket on Github repository .","title":"Issues"},{"location":"#license","text":"psr2-code-generator is released under the Apache2 license. A full copy of the license is shipped with the code into the file LICENSE .","title":"License"},{"location":"contributing/","text":"Psr2 Code Generator Contributing Guide Workflow Fork, clone and apply your patches. Run the test suite composer test and fix all red tests. Run static analysis tool (by now, we use Psalm ) composer analytics and fix all errors and issues. Fix the coding standard composer cs-fix . Tip We provide a check command to run all the tests and analytics, required for a pull request. Run composer check Running the Test Suite While developing, the test part is very important: if you apply a patch to the existing code, the test suite must run without errors or failures and if you add a new functionality, no one will consider it without tests. Our test tool is PhpUnit and we provide a script to launch it: composer test Since our command runs phpunit binary under the hood, you can pass all phpunit options to it via the -- operator, i.e.: composer test -- --stop-on-failure You can also use phpunit directly: vendor/bin/phpunit Code Coverage We provides two commands to generate a code coverage report in html or xml format. composer coverage:html command generates a code coverage report in html format, into the directory coverage/ while composer coverage:clover generates the report in xml format, into clover.xml file. Static Analysis Tool To prevent as many bugs as possible, we use a static analysis tool called Psalm . To launch it, run the following command from the root directory of psr2-code-generator project: composer analytics After its analysis, Psalm outputs errors and issues with its suggestions on how to fix them. Errors are more important and generally more dangerous than issues, anyway you should fix both. Coding Standard We ship our script to easily fix coding standard errors, via php-cs-fixer tool. To fix coding standard errors just run: composer cs-fix and to show the errors without fixing them, run: composer cs If you want to learn more about our code style, see https://github.com/susina/coding-standard . Documentation Contributing psr2-code-generator documentation resides into the directory docs/ . It's written in markdown and it's generated by MkDocs . Install the Tools If you want to contribute to the documentation, you should install the following tools, to generate it locally: Install MkDocs Install Material theme by running: pip install mkdocs-material Markdown flavour MkDocs uses Python-Markdown with some extensions active by default. It supports the standard markdown, markdown-extra and some of the Github-flavoured markdown features. You can find detailed information on https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown . Admonition admonition extension helps to write beautiful notes or warnings or other (see the official documentation) with a syntax like the following: !!! Danger Very dangerous operation! which translates into the following: Danger Very dangerous operation!","title":"Contributing"},{"location":"contributing/#psr2-code-generator-contributing-guide","text":"","title":"Psr2 Code Generator Contributing Guide"},{"location":"contributing/#workflow","text":"Fork, clone and apply your patches. Run the test suite composer test and fix all red tests. Run static analysis tool (by now, we use Psalm ) composer analytics and fix all errors and issues. Fix the coding standard composer cs-fix . Tip We provide a check command to run all the tests and analytics, required for a pull request. Run composer check","title":"Workflow"},{"location":"contributing/#running-the-test-suite","text":"While developing, the test part is very important: if you apply a patch to the existing code, the test suite must run without errors or failures and if you add a new functionality, no one will consider it without tests. Our test tool is PhpUnit and we provide a script to launch it: composer test Since our command runs phpunit binary under the hood, you can pass all phpunit options to it via the -- operator, i.e.: composer test -- --stop-on-failure You can also use phpunit directly: vendor/bin/phpunit","title":"Running the Test Suite"},{"location":"contributing/#code-coverage","text":"We provides two commands to generate a code coverage report in html or xml format. composer coverage:html command generates a code coverage report in html format, into the directory coverage/ while composer coverage:clover generates the report in xml format, into clover.xml file.","title":"Code Coverage"},{"location":"contributing/#static-analysis-tool","text":"To prevent as many bugs as possible, we use a static analysis tool called Psalm . To launch it, run the following command from the root directory of psr2-code-generator project: composer analytics After its analysis, Psalm outputs errors and issues with its suggestions on how to fix them. Errors are more important and generally more dangerous than issues, anyway you should fix both.","title":"Static Analysis Tool"},{"location":"contributing/#coding-standard","text":"We ship our script to easily fix coding standard errors, via php-cs-fixer tool. To fix coding standard errors just run: composer cs-fix and to show the errors without fixing them, run: composer cs If you want to learn more about our code style, see https://github.com/susina/coding-standard .","title":"Coding Standard"},{"location":"contributing/#documentation-contributing","text":"psr2-code-generator documentation resides into the directory docs/ . It's written in markdown and it's generated by MkDocs .","title":"Documentation Contributing"},{"location":"contributing/#install-the-tools","text":"If you want to contribute to the documentation, you should install the following tools, to generate it locally: Install MkDocs Install Material theme by running: pip install mkdocs-material","title":"Install the Tools"},{"location":"contributing/#markdown-flavour","text":"MkDocs uses Python-Markdown with some extensions active by default. It supports the standard markdown, markdown-extra and some of the Github-flavoured markdown features. You can find detailed information on https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown .","title":"Markdown flavour"},{"location":"contributing/#admonition","text":"admonition extension helps to write beautiful notes or warnings or other (see the official documentation) with a syntax like the following: !!! Danger Very dangerous operation! which translates into the following: Danger Very dangerous operation!","title":"Admonition"},{"location":"generator/","text":"Generator Now that your model is on the road, it's time to generate the code. To do this, a generator object is needed. <?php use Susina\\Codegen\\Generator\\CodeGenerator ; $class = .......... ; // code to create your model $generator = new CodeGenerator (); $code = $generator -> generate ( $class ); Now, our $code variable contains a string with the generated code, according to the previously created model: namespace \\\\my\\\\cool\\\\namespace; /** * Class level commen * * @author yourself */ class MyAwesomeClass extend FantasticFramework { //properties and methods according to the model ......... } If you plan to save your generated code into a file, you can use CodeFileGenerator class instead, which adds the additional needed tags and the file level comment. <?php use Susina\\Codegen\\Generator\\CodeFileGenerator ; $class = .......... ; // code to create your model $generator = new CodeFileGenerator (); $code = $generator -> generate ( $class ); Now, our $code variable contains: <?php declare ( strict_types = 1 ); /** * File level comment (e.g. copyright information and so on) */ namespace \\\\my\\\\cool\\\\namespace ; /** * Class level comment * * @author yourself */ class MyAwesomeClass extend FantasticFramework { //properties and methods according to the model ......... } Generator configuration The package ships with two generators, which are configurable through an associative array as constructor parameter. Alternatively if you have a project that uses the same configuration over and over again, extend the GeneratorConfig class and pass an instance of it instead of the configuration array. <?php use Susina\\Codegen\\Generator\\CodeGenerator ; // a) new code generator with options passed as array $generator = new CodeGenerator ([ 'generateEmptyDocblock' => true , ... ]); // b) new code generator with options passed as object $generator = new CodeGenerator ( new MyGenerationConfig ()); CodeGenerators in detail Generates code for a given model. It will also generate docblocks for all contained classes, methods, interfaces, etc. you have prior to generating the code. Class: Susina\\Codegen\\Generator\\CodeGenerator Options: Key Type Default Value Description generateEmptyDocblock boolean false Allows generation of empty docblocks enableSorting boolean true Enables sorting useStatementSorting boolean or string or Closure or Comparator default Sorting mechanism for use statements constantSorting boolean or string or Closure or Comparator default Sorting mechanism for constants propertySorting boolean or string or Closure or Comparator default Sorting mechanism for properties methodSorting boolean or string or Closure or Comparator default Sorting mechanism for methods php74Properties boolean false If true, generate classes with typed properties For sorting... ... a string will used to find a comparator with that name (at the moment there is only default). ... with a boolean you can disable sorting for a particular member ... you can pass in your own \\Closure for comparison ... you can pass in a Comparator for comparison Example: <?php use Susina\\Codegen\\Generator\\CodeGenerator ; // will set every option to true, because of the defaults $generator = new CodeGenerator ([ 'generateEmptyDocblock' => true , 'enableSorting' => true ]); $code = $generator -> generate ( $myClass ); CodeFileGenerator Generates a complete php file with the given model inside. Especially useful when creating PSR-4 compliant code, which you are about to dump into a file. It extends the CodeGenerator and as such inherits all its benefits. Class: Susina\\Codegen\\Generator\\CodeFileGenerator Options: Same options as CodeGenerator plus: Key Type Default Value Description headerComment null or string or Docblock null A comment, that will be put after the <?php statement headerDocblock null or string or Docblock null A docblock that will be positioned after the possible header comment Example: <?php use Susina\\Codegen\\Generator\\CodeFileGenerator ; $generator = new CodeGenerator ([ 'headerComment' => 'This will be placed at the top, woo' , 'headerDocblock' => 'Full documentation mode confirmed!' , ]); $code = $generator -> generate ( $myClass ); PHP 7.4+ typed class properties You can generate PHP 7.4+ classes with typed properties. Just set php74Properties configuration attribute to true , when you instantiate your generator: <?php use Susina\\Codegen\\Generator\\CodeGenerator ; $class = PhpClass :: create ( 'MyAwesomeClass' ) -> setDescription ( 'Class level comment' ) -> setNamespace ( '\\my\\cool\\namespace' ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setType ( 'string' ) -> setDescription ( 'The driver' ) ) ; $generator = new CodeGenerator ([ 'php74Properties' => true ]); $code = $generator -> generate ( $class ); It results in: <?php namespace \\my\\cool\\namespace ; /** * Class level comment */ class MyAwesomeClass { /** * @var string The driver */ protected string $driver ; } Template system for Code Bodies It is useful to use some kind of template system to load the contents for your method bodies, Mustache , Twig or else. The template system can also be used to replace variables in the templates.","title":"Generator"},{"location":"generator/#generator","text":"Now that your model is on the road, it's time to generate the code. To do this, a generator object is needed. <?php use Susina\\Codegen\\Generator\\CodeGenerator ; $class = .......... ; // code to create your model $generator = new CodeGenerator (); $code = $generator -> generate ( $class ); Now, our $code variable contains a string with the generated code, according to the previously created model: namespace \\\\my\\\\cool\\\\namespace; /** * Class level commen * * @author yourself */ class MyAwesomeClass extend FantasticFramework { //properties and methods according to the model ......... } If you plan to save your generated code into a file, you can use CodeFileGenerator class instead, which adds the additional needed tags and the file level comment. <?php use Susina\\Codegen\\Generator\\CodeFileGenerator ; $class = .......... ; // code to create your model $generator = new CodeFileGenerator (); $code = $generator -> generate ( $class ); Now, our $code variable contains: <?php declare ( strict_types = 1 ); /** * File level comment (e.g. copyright information and so on) */ namespace \\\\my\\\\cool\\\\namespace ; /** * Class level comment * * @author yourself */ class MyAwesomeClass extend FantasticFramework { //properties and methods according to the model ......... }","title":"Generator"},{"location":"generator/#generator-configuration","text":"The package ships with two generators, which are configurable through an associative array as constructor parameter. Alternatively if you have a project that uses the same configuration over and over again, extend the GeneratorConfig class and pass an instance of it instead of the configuration array. <?php use Susina\\Codegen\\Generator\\CodeGenerator ; // a) new code generator with options passed as array $generator = new CodeGenerator ([ 'generateEmptyDocblock' => true , ... ]); // b) new code generator with options passed as object $generator = new CodeGenerator ( new MyGenerationConfig ());","title":"Generator configuration"},{"location":"generator/#codegenerators-in-detail","text":"Generates code for a given model. It will also generate docblocks for all contained classes, methods, interfaces, etc. you have prior to generating the code. Class: Susina\\Codegen\\Generator\\CodeGenerator Options: Key Type Default Value Description generateEmptyDocblock boolean false Allows generation of empty docblocks enableSorting boolean true Enables sorting useStatementSorting boolean or string or Closure or Comparator default Sorting mechanism for use statements constantSorting boolean or string or Closure or Comparator default Sorting mechanism for constants propertySorting boolean or string or Closure or Comparator default Sorting mechanism for properties methodSorting boolean or string or Closure or Comparator default Sorting mechanism for methods php74Properties boolean false If true, generate classes with typed properties For sorting... ... a string will used to find a comparator with that name (at the moment there is only default). ... with a boolean you can disable sorting for a particular member ... you can pass in your own \\Closure for comparison ... you can pass in a Comparator for comparison Example: <?php use Susina\\Codegen\\Generator\\CodeGenerator ; // will set every option to true, because of the defaults $generator = new CodeGenerator ([ 'generateEmptyDocblock' => true , 'enableSorting' => true ]); $code = $generator -> generate ( $myClass );","title":"CodeGenerators in detail"},{"location":"generator/#codefilegenerator","text":"Generates a complete php file with the given model inside. Especially useful when creating PSR-4 compliant code, which you are about to dump into a file. It extends the CodeGenerator and as such inherits all its benefits. Class: Susina\\Codegen\\Generator\\CodeFileGenerator Options: Same options as CodeGenerator plus: Key Type Default Value Description headerComment null or string or Docblock null A comment, that will be put after the <?php statement headerDocblock null or string or Docblock null A docblock that will be positioned after the possible header comment Example: <?php use Susina\\Codegen\\Generator\\CodeFileGenerator ; $generator = new CodeGenerator ([ 'headerComment' => 'This will be placed at the top, woo' , 'headerDocblock' => 'Full documentation mode confirmed!' , ]); $code = $generator -> generate ( $myClass );","title":"CodeFileGenerator"},{"location":"generator/#php-74-typed-class-properties","text":"You can generate PHP 7.4+ classes with typed properties. Just set php74Properties configuration attribute to true , when you instantiate your generator: <?php use Susina\\Codegen\\Generator\\CodeGenerator ; $class = PhpClass :: create ( 'MyAwesomeClass' ) -> setDescription ( 'Class level comment' ) -> setNamespace ( '\\my\\cool\\namespace' ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setType ( 'string' ) -> setDescription ( 'The driver' ) ) ; $generator = new CodeGenerator ([ 'php74Properties' => true ]); $code = $generator -> generate ( $class ); It results in: <?php namespace \\my\\cool\\namespace ; /** * Class level comment */ class MyAwesomeClass { /** * @var string The driver */ protected string $driver ; }","title":"PHP 7.4+ typed class properties"},{"location":"generator/#template-system-for-code-bodies","text":"It is useful to use some kind of template system to load the contents for your method bodies, Mustache , Twig or else. The template system can also be used to replace variables in the templates.","title":"Template system for Code Bodies"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"model/","text":"Model A model is a representation of your code, that you can create via the fluent api. There are different types of models available which are explained in this section. Structured Generateable Models Structured models are composites and can contain other models. Structured models implement the GenerateableInterface and can be passed to a generator. These are: PhpClass representing a class, with all its methods, properties, comments etc. PhpTrait representing a trait with all its methods, properties etc. PhpInterface representing an interface with all its method signatures, property definitions atc. Part Models Structured models can be composed of various members. Functions and methods can itself contain zero to many parameters. All parts are: PhpConstant representing a constant PhpProperty representing a property PhpMethod representing a method PhpParameter representing a function or method parameter Name vs. Namespace vs. Qualified Name ? There can be a little struggle about the different names, which are name, namespace and qualified name. Every model has a name and generateable models additionally have a namespace and qualified name. The qualified name is a combination of namespace + name. Here is an overview: Name Tool Namespace my\\cool Qualified Name my\\cool\\Tool Create your first Class Let's start with a simple example: <?php use Susina\\Codegen\\Model\\PhpClass ; $class = new PhpClass (); $class -> setQualifiedName ( 'my\\\\cool\\\\Tool' ); which will generate an empty class: <?php namespace my\\cool ; class Tool { } Adding a Constructor It's better to have a constructor, so we add one: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; // You can pass the name or the qualified name when you instantiate your model $class = new PhpClass ( 'my\\\\cool\\\\Tool' ); $class -> setMethod ( PhpMethod :: create ( '__construct' ) -> addParameter ( PhpParameter :: create ( 'target' ) -> setType ( 'string' ) -> setDescription ( 'Creates my Tool' ) ) ) ; you can see the fluent API in action and the snippet above will generate: <?php namespace my\\cool ; class Tool { /** * @param string $target Creates my Tool */ public function __construct ( string $target ) { } } Adding members We've just learned how to pass a blank method, the constructor to the class. We can also add properties, constants and of course methods. Let's do so: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; use Susina\\Codegen\\Model\\PhpProperty ; use Susina\\Codegen\\Model\\PhpConstant ; $class = PhpClass :: create ( 'my\\\\cool\\\\Tool' ) -> setMethod ( PhpMethod :: create ( 'setDriver' ) -> addParameter ( PhpParameter :: create ( 'driver' ) -> setType ( 'string' ) ) -> setType ( 'bool' ) // optional if you want return type -> setBody ( \" \\$ this->driver = \\$ driver; return true;\" ) ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setVisibility ( 'private' ) -> setType ( 'string' ) ) -> setConstant ( new PhpConstant ( 'FOO' , 'bar' )) ; will generate: <?php namespace my\\cool ; class Tool { /** */ const FOO = 'bar' ; /** * @var string */ private $driver ; /** * * @param string $driver * @return bool */ public function setDriver ( string $driver ) : bool { $this -> driver = $driver ; return true ; } } Let's add some docblock comments, too: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; use Susina\\Codegen\\Model\\PhpProperty ; use Susina\\Codegen\\Model\\PhpConstant ; $class = PhpClass :: create ( 'my\\\\cool\\\\Tool' ) -> setMultilineDescription ([ \"The fantastic Tool class.\" , \"\" , \"@author John Smith\" ]) -> setMethod ( PhpMethod :: create ( 'setDriver' ) -> setDescription ( \"Set the specific driver\" ) -> addParameter ( PhpParameter :: create ( 'driver' ) -> setType ( 'string' ) -> setDescription ( \"The driver\" ) ) -> setType ( 'bool' ) -> setTypeDescription ( \"If everything is ok\" ) -> setBody ( \" \\$ this->driver = \\$ driver; return true;\" ) ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setVisibility ( 'private' ) -> setType ( 'string' ) -> setDescription ( \"The driver\" ) ) -> setConstant (( new PhpConstant ( 'FOO' , 'bar' )) -> setDescription ( \"The FOO constant\" ) ) ; will generate: <?php namespace my\\cool ; /** * The fantastic Tool class * * @author John Smith */ class Tool { /** * The FOO constant */ const FOO = 'bar' ; /** * The driver * * @var string */ private $driver ; /** * Set the specific driver * * @param string $driver * @return bool If everything is ok */ public function setDriver ( string $driver ) : bool { $this -> driver = $driver ; return true ; } } Declare use statements When you put code inside a method there can be a reference to a class or interface, where you normally put the qualified name into a use statement. So here is how you do it: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; $class = new PhpClass (); $class -> setName ( 'Tool' ) -> setNamespace ( 'my\\\\cool' ) -> setMethod ( PhpMethod :: create ( '__construct' ) -> setBody ( '$request = Request::createFromGlobals();' ) ) -> declareUse ( 'Symfony\\\\Component\\\\HttpFoundation\\\\Request' ) ; which will create: <?php namespace my\\cool ; use Symfony\\Component\\HttpFoundation\\Request ; class Tool { /** */ public function __construct () { $request = Request :: createFromGlobals (); } } Understanding Values The models PhpConstant , PhpParameter and PhpProperty support values; all of them implement the ValueInterface . Each value object has a type, a value (of course) or an expression. There is a difference between values and expressions. Values refer to language primitives ( string , int , float , bool and null ). Additionally you can set a PhpConstant as value (the lib understands this as a library primitive ;-). If you want more complex control over the output, you can set an expression instead, which will be generated as is . Some Examples: <?php PhpProperty :: create ( 'foo' ) -> setValue ( 'hello world.' ); // $foo = 'hello world.'; PhpProperty :: create ( 'foo' ) -> setValue ( 300 ); // $foo = 300; PhpProperty :: create ( 'foo' ) -> setValue ( 3.14 ); // $foo = 3.14; PhpProperty :: create ( 'foo' ) -> setValue ( false ); // $foo = false; PhpProperty :: create ( 'foo' ) -> setValue ( null ); // $foo = null; PhpProperty :: create ( 'foo' ) -> setValue ( PhpConstant :: create ( 'BAR' )); // $foo = BAR; PhpProperty :: create ( 'foo' ) -> setExpression ( 'self::MY_CONST' ); // $foo = self::MY_CONST; PhpProperty :: create ( 'foo' ) -> setExpression ( \"['my' => 'array']\" ); // $foo = ['my' => 'array']; For retrieving values there is a hasValue() method which returns true whether there is a value or an expression present. To be sure what is present there is also an isExpression() method which you can use as a second check: <?php if ( $prop -> hasValue ()) { if ( $prop -> isExpression ()) { // do something with an expression } else { // do something with a value } } More about types Returning $this for fluent interface When you write a class with fluent interface, you want to specify that a method returns $this or the class itself. You can pass the docblock notation to the setType method. I.e. <?php $method = new PhpMethod ( 'setDriver' ); $method -> setType ( '$this|FileManager' ) -> setTypeDescription ( 'For fluent interface' ) ; and it'll result: <?php ............ /** * @return $this|FileManager For fluent interface */ public function setDriver () : FileManager {} If your method is part of a class, the type of $this is auto-discovered: <?php $class = new PhpClass ( 'FileManager' ); $method = PhpMethod :: create ( 'setDriver' ) -> setType ( '$this' ) -> setTypeDescription ( 'For fluent interface' ) ; $class -> setMethod ( $method ); It'll result: <?php ............... class FileManager { /** * @return $this|FileManager For fluent interface */ public function setDriver () : FileManager {} } Nullable types When you want to define a nullable type, you can use both docblock notation (i.e. int|null ) and Php one (i.e. ?int ): <?php // Docblock notation $method = PhpMethod :: create ( 'fileSize' ) -> setType ( 'int|null' ); // or PHP notation $method1 = PhpMethod :: create ( 'fileDescription' ) -> setType ( '?string' ); The result is: <?php ................... /** * @return int|null */ public function fileSize () : ? int {} /** * @return string|null */ public function fileDescription () : ? string {} Much, much more The API has a lot more to offer and has almost full support for what you would expect to manipulate on each model, of course everything is fluent API.","title":"Model"},{"location":"model/#model","text":"A model is a representation of your code, that you can create via the fluent api. There are different types of models available which are explained in this section.","title":"Model"},{"location":"model/#structured-generateable-models","text":"Structured models are composites and can contain other models. Structured models implement the GenerateableInterface and can be passed to a generator. These are: PhpClass representing a class, with all its methods, properties, comments etc. PhpTrait representing a trait with all its methods, properties etc. PhpInterface representing an interface with all its method signatures, property definitions atc.","title":"Structured Generateable Models"},{"location":"model/#part-models","text":"Structured models can be composed of various members. Functions and methods can itself contain zero to many parameters. All parts are: PhpConstant representing a constant PhpProperty representing a property PhpMethod representing a method PhpParameter representing a function or method parameter","title":"Part Models"},{"location":"model/#name-vs-namespace-vs-qualified-name","text":"There can be a little struggle about the different names, which are name, namespace and qualified name. Every model has a name and generateable models additionally have a namespace and qualified name. The qualified name is a combination of namespace + name. Here is an overview: Name Tool Namespace my\\cool Qualified Name my\\cool\\Tool","title":"Name vs. Namespace vs. Qualified Name ?"},{"location":"model/#create-your-first-class","text":"Let's start with a simple example: <?php use Susina\\Codegen\\Model\\PhpClass ; $class = new PhpClass (); $class -> setQualifiedName ( 'my\\\\cool\\\\Tool' ); which will generate an empty class: <?php namespace my\\cool ; class Tool { }","title":"Create your first Class"},{"location":"model/#adding-a-constructor","text":"It's better to have a constructor, so we add one: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; // You can pass the name or the qualified name when you instantiate your model $class = new PhpClass ( 'my\\\\cool\\\\Tool' ); $class -> setMethod ( PhpMethod :: create ( '__construct' ) -> addParameter ( PhpParameter :: create ( 'target' ) -> setType ( 'string' ) -> setDescription ( 'Creates my Tool' ) ) ) ; you can see the fluent API in action and the snippet above will generate: <?php namespace my\\cool ; class Tool { /** * @param string $target Creates my Tool */ public function __construct ( string $target ) { } }","title":"Adding a Constructor"},{"location":"model/#adding-members","text":"We've just learned how to pass a blank method, the constructor to the class. We can also add properties, constants and of course methods. Let's do so: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; use Susina\\Codegen\\Model\\PhpProperty ; use Susina\\Codegen\\Model\\PhpConstant ; $class = PhpClass :: create ( 'my\\\\cool\\\\Tool' ) -> setMethod ( PhpMethod :: create ( 'setDriver' ) -> addParameter ( PhpParameter :: create ( 'driver' ) -> setType ( 'string' ) ) -> setType ( 'bool' ) // optional if you want return type -> setBody ( \" \\$ this->driver = \\$ driver; return true;\" ) ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setVisibility ( 'private' ) -> setType ( 'string' ) ) -> setConstant ( new PhpConstant ( 'FOO' , 'bar' )) ; will generate: <?php namespace my\\cool ; class Tool { /** */ const FOO = 'bar' ; /** * @var string */ private $driver ; /** * * @param string $driver * @return bool */ public function setDriver ( string $driver ) : bool { $this -> driver = $driver ; return true ; } } Let's add some docblock comments, too: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; use Susina\\Codegen\\Model\\PhpParameter ; use Susina\\Codegen\\Model\\PhpProperty ; use Susina\\Codegen\\Model\\PhpConstant ; $class = PhpClass :: create ( 'my\\\\cool\\\\Tool' ) -> setMultilineDescription ([ \"The fantastic Tool class.\" , \"\" , \"@author John Smith\" ]) -> setMethod ( PhpMethod :: create ( 'setDriver' ) -> setDescription ( \"Set the specific driver\" ) -> addParameter ( PhpParameter :: create ( 'driver' ) -> setType ( 'string' ) -> setDescription ( \"The driver\" ) ) -> setType ( 'bool' ) -> setTypeDescription ( \"If everything is ok\" ) -> setBody ( \" \\$ this->driver = \\$ driver; return true;\" ) ) -> setProperty ( PhpProperty :: create ( 'driver' ) -> setVisibility ( 'private' ) -> setType ( 'string' ) -> setDescription ( \"The driver\" ) ) -> setConstant (( new PhpConstant ( 'FOO' , 'bar' )) -> setDescription ( \"The FOO constant\" ) ) ; will generate: <?php namespace my\\cool ; /** * The fantastic Tool class * * @author John Smith */ class Tool { /** * The FOO constant */ const FOO = 'bar' ; /** * The driver * * @var string */ private $driver ; /** * Set the specific driver * * @param string $driver * @return bool If everything is ok */ public function setDriver ( string $driver ) : bool { $this -> driver = $driver ; return true ; } }","title":"Adding members"},{"location":"model/#declare-use-statements","text":"When you put code inside a method there can be a reference to a class or interface, where you normally put the qualified name into a use statement. So here is how you do it: <?php use Susina\\Codegen\\Model\\PhpClass ; use Susina\\Codegen\\Model\\PhpMethod ; $class = new PhpClass (); $class -> setName ( 'Tool' ) -> setNamespace ( 'my\\\\cool' ) -> setMethod ( PhpMethod :: create ( '__construct' ) -> setBody ( '$request = Request::createFromGlobals();' ) ) -> declareUse ( 'Symfony\\\\Component\\\\HttpFoundation\\\\Request' ) ; which will create: <?php namespace my\\cool ; use Symfony\\Component\\HttpFoundation\\Request ; class Tool { /** */ public function __construct () { $request = Request :: createFromGlobals (); } }","title":"Declare use statements"},{"location":"model/#understanding-values","text":"The models PhpConstant , PhpParameter and PhpProperty support values; all of them implement the ValueInterface . Each value object has a type, a value (of course) or an expression. There is a difference between values and expressions. Values refer to language primitives ( string , int , float , bool and null ). Additionally you can set a PhpConstant as value (the lib understands this as a library primitive ;-). If you want more complex control over the output, you can set an expression instead, which will be generated as is . Some Examples: <?php PhpProperty :: create ( 'foo' ) -> setValue ( 'hello world.' ); // $foo = 'hello world.'; PhpProperty :: create ( 'foo' ) -> setValue ( 300 ); // $foo = 300; PhpProperty :: create ( 'foo' ) -> setValue ( 3.14 ); // $foo = 3.14; PhpProperty :: create ( 'foo' ) -> setValue ( false ); // $foo = false; PhpProperty :: create ( 'foo' ) -> setValue ( null ); // $foo = null; PhpProperty :: create ( 'foo' ) -> setValue ( PhpConstant :: create ( 'BAR' )); // $foo = BAR; PhpProperty :: create ( 'foo' ) -> setExpression ( 'self::MY_CONST' ); // $foo = self::MY_CONST; PhpProperty :: create ( 'foo' ) -> setExpression ( \"['my' => 'array']\" ); // $foo = ['my' => 'array']; For retrieving values there is a hasValue() method which returns true whether there is a value or an expression present. To be sure what is present there is also an isExpression() method which you can use as a second check: <?php if ( $prop -> hasValue ()) { if ( $prop -> isExpression ()) { // do something with an expression } else { // do something with a value } }","title":"Understanding Values"},{"location":"model/#more-about-types","text":"","title":"More about types"},{"location":"model/#returning-this-for-fluent-interface","text":"When you write a class with fluent interface, you want to specify that a method returns $this or the class itself. You can pass the docblock notation to the setType method. I.e. <?php $method = new PhpMethod ( 'setDriver' ); $method -> setType ( '$this|FileManager' ) -> setTypeDescription ( 'For fluent interface' ) ; and it'll result: <?php ............ /** * @return $this|FileManager For fluent interface */ public function setDriver () : FileManager {} If your method is part of a class, the type of $this is auto-discovered: <?php $class = new PhpClass ( 'FileManager' ); $method = PhpMethod :: create ( 'setDriver' ) -> setType ( '$this' ) -> setTypeDescription ( 'For fluent interface' ) ; $class -> setMethod ( $method ); It'll result: <?php ............... class FileManager { /** * @return $this|FileManager For fluent interface */ public function setDriver () : FileManager {} }","title":"Returning $this for fluent interface"},{"location":"model/#nullable-types","text":"When you want to define a nullable type, you can use both docblock notation (i.e. int|null ) and Php one (i.e. ?int ): <?php // Docblock notation $method = PhpMethod :: create ( 'fileSize' ) -> setType ( 'int|null' ); // or PHP notation $method1 = PhpMethod :: create ( 'fileDescription' ) -> setType ( '?string' ); The result is: <?php ................... /** * @return int|null */ public function fileSize () : ? int {} /** * @return string|null */ public function fileDescription () : ? string {}","title":"Nullable types"},{"location":"model/#much-much-more","text":"The API has a lot more to offer and has almost full support for what you would expect to manipulate on each model, of course everything is fluent API.","title":"Much, much more"},{"location":"user_guide/","text":"User Guide Now that you have the library installed, it's time to start to generate some code. The workflow to do it consists in three steps: Create a model Create a generator Generate the code contained in the model, via the generator object","title":"User Guide"},{"location":"user_guide/#user-guide","text":"Now that you have the library installed, it's time to start to generate some code. The workflow to do it consists in three steps: Create a model Create a generator Generate the code contained in the model, via the generator object","title":"User Guide"}]}